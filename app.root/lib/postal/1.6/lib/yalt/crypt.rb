# -*- coding: utf-8 -*-

module YALTools
  
  # == Description
  #
  # YALTools::Crypt module provides encryption and decryption methods.
  #
  # == Common Secret Key File Format
  #
  # This module methods uses the common key file named +sec_conf_file+.
  #
  # The +sec_conf_file+ is the json format like as the following;
  #
  #   {"sec_text":"xxxx_secret_keys_xxxx"}
  #
  # == Usage
  # 
  # === Initialize a common key file
  # The +sec_conf_file.txt+ can be generated by a text editor.
  # This is just an example for your convenience.
  # 
  #   pass = YALTools::Crypt::gen_password
  #   YALTools::Crypt::save_crypt_password(pass, "sec_conf_file.txt")
  #
  # === Encrypttion
  #
  #   plain_text = "plain_text"
  #   text,salt = YALTools::Crypt::encrypt_text("sec_conf_file.txt", plain_text)
  #
  # === Decryption
  #
  #   plain_text = YALTools::Crypt::decrypt_text("sec_conf_file.txt", salt, text)
  #
  # === Salt
  #
  # The "salt" is the special eight-octet string which is required for encryption.
  # If the same salt is used for encryption, the encrypted string will be the same.
  #
  # To verify the encrypted string, you can set the default salt text.
  # However, in production use, to use the automatic generated string is recommended.
  #
  # In the decrypt_text method, the ENV["YALTSALT"] is used as the salt text when the given salt is empty.
  #
  # The +salt+ string will be pack() or unpack() by template, "H*".
  # It means that the +salt.bytesize()+ should be 16.
  #
  module Crypt
    require 'date'
    require 'digest/sha2'
    require 'openssl'
    
    # returns a random string using the Digest::SHA2::hexdigest method.
    # It aims to generate a default common key.
    def gen_password
      raw_pass = ""
      if FileTest.exist?('/dev/urandom')
        open('/dev/urandom') do |f|
          raw_pass += f.read(256).to_s
        end
      end
      raw_pass += DateTime.now.inspect.to_s + (DateTime.now.strftime("%Q").to_i * rand).to_s
      ## e.x.) raw_pass #=> "#<DateTime: 2011-01-26T13:31:18+09:00 (1697302210231950661/691200000000,3/8,2299161)>"
      pass = Digest::SHA2::hexdigest(raw_pass)
      return pass
    end
    module_function :gen_password
    
    # writes the +pass+ into the +sec_conf_file+ by json format.
    def save_crypt_password(pass, sec_conf_file, perms=0600)
      h = {}
      h['sec_text'] = pass
      open(sec_conf_file, "w", perms) do |f|
        f.puts(h.to_json)
        f.flush
      end
    end
    module_function :save_crypt_password
    
    # returns [encrypted_text, salt].
    def encrypt_text(sec_conf_file, plain_text, salt="")
      pass = load_crypt_password(sec_conf_file)
      salt = [salt.to_s].pack("H*") if salt.respond_to?("to_s")
      salt = OpenSSL::Random.random_bytes(8) if salt.empty? or salt.length != 8
      enc = OpenSSL::Cipher.new('aes-256-cbc')
      enc.encrypt
      enc.pkcs5_keyivgen(pass.to_s, salt.to_s, 2048)
      e_text = enc.update(plain_text) + enc.final
      return e_text.unpack("H*").join, salt.unpack("H*").join
    end
    module_function :encrypt_text

    # returns the decrypted string.
    #
    # If the "YALTSALT" envrionment variable is set, the ENV["YALTSALT"] overwrites the +salt+ variable.
    #
    def decrypt_text(sec_conf_file, salt, text)
      pass = load_crypt_password(sec_conf_file)
      salt = salt.to_s if salt.respond_to?("to_s")
      salt = ENV["YALTSALT"] if [salt].pack("H*").length != 8 and ENV.has_key?("YALTSALT")
      salt = "" if salt == nil
      n_salt = [salt].pack("H*")
      n_text = [text].pack("H*")
      enc = OpenSSL::Cipher.new('aes-256-cbc')
      enc.decrypt
      enc.pkcs5_keyivgen(pass.to_s, n_salt.to_s, 2048)
      return enc.update(n_text) + enc.final
    end
    module_function :decrypt_text

    private

    # It is for internal use only.
    def load_crypt_password(sec_conf_file)
      JSON.parse(open(sec_conf_file, "r").read)['sec_text']
    end
    module_function :load_crypt_password
  end
end
